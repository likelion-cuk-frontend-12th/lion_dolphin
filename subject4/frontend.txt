1. 라벨 태그의 역할과 React에서는 for옵션이 아니라 htmlFor옵션을 사용하
는 이유에 대해 설명해보세요.

A : 라벨 태그는 input 태그와 연결하기 위해 사용하는 태그이다. 
htmlFor을 사용하는 이유는 리액트에서 for는 for문을 의미하기 때문에 htmlFor 옵션을 사용한다. 
htmlFor에 input의 아이디나 네임을 적어 연결할 수 있다.
https://velog.io/@hazel123/htmlFor

2. Javascript의 비구조화 할당 방식과 과제 코드의 어느 부분에서 사용되었는
지 설명해보세요.

A : 자바스크립트의 비구조화 할당 방식은 구조 분해 할당이라고도 표현한다. 
비구조화 할당이란 배열([])이나 객체({}) 속성을 해체하여 개별 변수에 값을 담을 수 있는 자바스크립트 표현식을 말한다. 
비구조화 할당의 기본 구조는 좌측에는 변수, 우측에는 해당 변수에 넣어지는 값을 표현한다. 
비구조화 할당을 사용하면 필요한 객체와 나머지 요소 분리가 매우 간단해진다.
과제 코드 부분에선 React.useState에서 사용되었고 버튼 컴포넌트에서 props 객체의 속성을 비구조화 할당 방식으로 사용하였다.
https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B9%84%EA%B5%AC%EC%A1%B0%ED%99%94%EA%B5%AC%EC%A1%B0%EB%B6%84%ED%95%B4-%ED%95%A0%EB%8B%B9

3. 인터프리터와 컴파일러의 차이와 이를 중점으로 Javascript의 특징에 대해
설명해보세요. (Javascript는 단순한 인터프리터 언어가 아니에요!)

A : 인터프리터는 사람이 알아보기 쉬운 프로그래밍 언어로 작성한 코드를 한 줄 씩 즉시 기계어로 변역하는 번역기이다. 
인터프리터는 즉각적인 번역에 특화된 번역기로 번역 속도가 빠르다. 
컴파일이란 한 언어로 작성된 소스 코드를 다른 언어로 변환하는 것이다. 
c언어는 기계어로, java 코드는 바이트 코드로 옮기는 컴파일 과정을 거친다.
자바스크립트는 컴파일과 인터프리트 두 과정을 전부 거친다. 
코드를 바로 읽어 실행하는 것 보다 기계에 친화적인 언어로 컴파일 한 후 그 결과물을 인터프리트한다.
https://norwayy.tistory.com/354

4. Javascript에서 var보다 let, const 사용을 지향해야하는 이유를 설명해보
세요. (변수 호이스팅에 대해 공부해보면 좋겠어요)

A : let, const의 사용이 var보다 변수의 범위, 재할당 가능성 등에서 더 많은 장점을 제공하기 때문이다. 
var는 함수 범위를 가지며 let,const는 블록 범위를 가진다.
var는 재할당과 재선언이 모두 가능하며 let은 재할당은 가능하지만 재선언은 불가하고 const는 재할당, 재선언이 불가하다.
변수 호이스팅이란 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다.
let과 const는 변수를 선언하기 전에 참조할 수 없다. 초기화 되지 않는다. 참조 오류가 발생한다.
let은 변수 선언시 할당을 반드시 할 필요는 없지만 const는 변수를 선언할 시 할당을 반드시 해야한다.
var는 변수 선언이 범위의 최상단으로 끌어올려지는 것처럼 동작한다. 값은 undefined로 초기화되며 변수를 선언하기 전에 참조할 수 있다.
https://www.freecodecamp.org/korean/news/var-let-constyi-caijeomeun/

5. Javascript에서 함수 선언식과 함수 표현식에 대해 설명해보세요. (함수 호이
스팅에 대해 공부해보면 좋겠어요)

A : 자바스크립트에서 함수를 변수에 담을 수 있다. 이렇게 사용하는 것을 함수 표현식이라고 한다.
function 함수를 선언하는 것을 함수 선언문이라고 한다.
주요 차이점은 호이스팅에서 차이가 발생한다. 함수 선언식은 함수 전체를 호이스팅한다. 
정의된 범위의 맨 위로 호이스팅돼서 함수 선언 전에 함수를 사용할 수 있다.
함수 표현식은 별도의 변수에 할당하게 되는데 변수는 선언부와 할당부를 나누어 호이스팅하게 된다. 선언부만 호이스팅한다. 
https://taenami.tistory.com/86

6. Javascript에서 콜백함수와 비동기 처리에 대해 설명해보세요.

A : 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미한다.
콜백 함수란 나중에 호출되는 함수인데 싱글 스레드로 동작하는 자바스크립트에서 비동기적 프로그래밍을 구현하는데 사용한다.
콜백 함수는 일반적으로 다른 함수에 넘기거나 객체의 프로퍼티로 사용하며 보통 익명함수로 사용한다.
비동기 처리에 콜백함수를 이용하게 되면 비동기 처리를 중첩시켜서 코드를 작성하기 때문에 중첩으로 인한 복잡도가 증가하게 된다.
콜백 지옥 현상을 해결하기 위한 방법으로는 promise, async & await가 있다.
https://medium.com/@flqjsl/%EC%BD%9C%EB%B0%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-56c26e1f1bc3

7. 바벨이란?

A : 바벨은 자바스크립트 컴파일러이다.
바벨은 최신 자바스크립트 문법을 오래된 브라우저가 이해할 수 있도록 오래된 문법으로 변환한다.
바벨은 소스코드를 분석하여 AST로 변환한다. AST는 소스 코드의 추상 구문 구조의 트리이다.
생성된 AST를 브라우저가 지원하는 오래된 문법으로 AST를 변경한다. 새로운 AST를 바탕으로 새로운 코드를 생성한다.
https://velog.io/@suyeon9456/Babel

8. React 엘리먼트와 JSX에 대해서 설명해보세요.

A : JSX는 자바스크립트의 문법 확장이다. JSX는 리액트의 요소를 만든다.
JSX 태그의 첫 부분은 React element의 타입을 결정한다.
대문자로 시작하는 JSX 태그는 React 컴포넌트를 지정한다. 이 태그들은 같은 이름을 가진 변수들을 직접 참조한다.
JSX는 React.createElement를 호출하는 코드로 컴파일 되기 때문에 React 라이브러리 역시 JSX 코드와 같은 범위 내에 존재해야만 한다.
https://reactjs-kr.firebaseapp.com/docs/introducing-jsx.html
https://ko.legacy.reactjs.org/docs/jsx-in-depth.html

9. 브라우저의 DOM과 React의 virtual DOM에 대해서 설명해보세요.

A : DOM이란 Document Object Model로 HTML이란 코드로 설계된 웹페이지가 브라우저 안에서 화면에 나타나고
이벤트에 반응하며 값을 입력받는 등 기능들을 수행할 객체들로 실체화된 형태를 의미한다.
Virtual DOM이란 실제 DOM을 모방하는 형태로 메모리 상에서만 존재하는 가상의 DOM을 의미한다.
변화가 실제 DOM에 적용되기 전에 가상의 DOM을 한 번 거쳐 미리 처리하고 저장한 후 실제 DOM에 업데이트 할 수 있게 해준다.
데이터가 변경되면 전체 UI는 Virtual DOM에 렌더링 되어져 이전 virtual DOM에 있던 내용과 업데이트 후에 내용을 비교하여
바뀐 부분만 실제 DOM에 적용시킨다. 예를 들어 요소가 30개가 바뀌었다고 레이아웃을 30개씩 새로 하는 것이 아니라 모든 변화를
하나로 묶어서 딱 한번만 실행시킨다. 이렇게 연산 횟수를 줄일 수 있어 실제 DOM 리렌더링에 비해 효율적이다. 
https://velog.io/@ye-ji/DOM-vs-Virtual-DOM

10. React의 리렌더링 조건에 대해서 설명해보세요.

A : 
1. 컴포넌트의 state가 변경되었을 때
2. 컴포넌트가 상속받은 props가 변경되었을 때
3. 부모 컴포넌트가 리렌더링이 된 경우 자식 컴포넌트는 모두 리렌더링된다.
리액트에서 렌더링이 일어나면 UI를 다시 그려주는 작업을 실시한다.
리렌더링이 자주 일어나면 메모리가 소모되고 비용이 발생하게 된다.
불필요한 렌더링이 발생하지 않게 최적화 작업을 해야할 필요가 있다.
불필요한 렌더링을 방지하기 위해 React.memo라는 훅이 있다. 컴포넌트를 메모리에 저장해두고 필요할 때 가져다 쓴다.
부모 컴포넌트의 state 변경으로 인해 props의 변경이 일어나지 않는 한 컴포넌트는 리렌더링 되지 않는데 이것을
컴포넌트 memoization이라고 한다.
https://velog.io/@ehdxka3/%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%A1%B0%EA%B1%B4React